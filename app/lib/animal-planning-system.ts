import type { Animal, AnimalPosition } from "../types/animal";

export interface PlanStep {
  id: string;
  action: string;
  parameters?: any;
  targetPosition?: AnimalPosition;
  priority: number; // 1-10, higher = more important
  turnOffset: number; // How many turns in the future (0 = this turn)
  expectedBenefit: number; // Estimated benefit score
  requirements?: {
    energy?: number;
    materials?: { stone?: number; wood?: number };
    nearBuilding?: boolean;
    inBuilding?: boolean;
  };
  reason: string; // Why this step is planned
}

export interface AnimalPlan {
  animalId: string;
  steps: PlanStep[];
  createdAt: number;
  lastUpdated: number;
  planHorizon: number; // How many turns ahead to plan (3-10)
  currentStepIndex: number;
  confidence: number; // 0-1, how confident the AI is in this plan
  planType: "survival" | "building" | "exploration" | "social" | "mixed";
}

export interface PlanningContext {
  urgentNeeds: string[]; // ["energy", "shelter", "food", "water"]
  availableResources: { stone: number; wood: number; food: number; water: number };
  nearbyBuildings: any[];
  weatherThreat: boolean;
  socialOpportunities: string[];
  energyProjection: number[]; // Projected energy for next N turns
  memoryInsights: string[]; // Key memories affecting planning
}

export class AnimalPlanningSystem {
  private plans: Map<string, AnimalPlan> = new Map();
  private planningHistory: Map<string, AnimalPlan[]> = new Map();

  constructor() {
    // Initialize the planning system
  }

  /**
   * Store a plan generated by the LLM
   */
  storePlan(plan: AnimalPlan): void {
    this.plans.set(plan.animalId, plan);
    this.storePlanHistory(plan.animalId, plan);
  }

  /**
   * Check if animal should create a new plan (called by LLM decision logic)
   */
  shouldCreateNewPlan(animal: Animal, worldState: any): boolean {
    const existingPlan = this.plans.get(animal.id);
    const context = this.analyzePlanningContext(animal, worldState);
    
    return !existingPlan || this.shouldReplan(animal, existingPlan, context);
  }

  /**
   * Get the current step that should be executed
   */
  getCurrentStep(animalId: string): PlanStep | null {
    const plan = this.plans.get(animalId);
    if (!plan || plan.currentStepIndex >= plan.steps.length) {
      return null;
    }
    
    const currentStep = plan.steps[plan.currentStepIndex];
    
    // Only return step if it's for the current turn
    if (currentStep.turnOffset === 0) {
      return currentStep;
    }
    
    return null;
  }

  /**
   * Mark current step as completed and advance plan
   */
  completeCurrentStep(animalId: string, success: boolean): void {
    const plan = this.plans.get(animalId);
    if (!plan) return;

    // Mark step as completed
    const currentStep = plan.steps[plan.currentStepIndex];
    if (currentStep) {
      // Adjust confidence based on success
      plan.confidence *= success ? 1.1 : 0.9;
      plan.confidence = Math.max(0.1, Math.min(1.0, plan.confidence));
    }

    // Advance to next step
    plan.currentStepIndex++;
    
    // Decrement turnOffset for all remaining steps
    for (let i = plan.currentStepIndex; i < plan.steps.length; i++) {
      plan.steps[i].turnOffset = Math.max(0, plan.steps[i].turnOffset - 1);
    }

    plan.lastUpdated = Date.now();
    this.plans.set(animalId, plan);
  }

  /**
   * Get planning insights for AI prompt
   */
  getPlanningInsights(animalId: string): string {
    const plan = this.plans.get(animalId);
    if (!plan) {
      return "No current plan. Consider making a 3-10 turn plan based on your needs.";
    }

    const currentStep = this.getCurrentStep(animalId);
    const upcomingSteps = plan.steps
      .slice(plan.currentStepIndex + 1, plan.currentStepIndex + 4)
      .map(step => `Turn +${step.turnOffset}: ${step.action} (${step.reason})`)
      .join(", ");

    const planSummary = `Plan (${plan.planType}, confidence: ${Math.round(plan.confidence * 100)}%): ` +
      (currentStep ? `Now: ${currentStep.action} (${currentStep.reason})` : "No current step") +
      (upcomingSteps ? `. Next: ${upcomingSteps}` : "");

    return planSummary;
  }

  /**
   * Check if animal can sleep (must be in building)
   */
  canSleep(animal: Animal, worldState: any): { canSleep: boolean; reason: string } {
    // Check if animal is in any building
    const nearbyBuildings = worldState.nearbyBuildings || [];
    const isInBuilding = nearbyBuildings.some((building: any) => {
      const distance = Math.sqrt(
        Math.pow(building.position.x - animal.position.x, 2) +
        Math.pow(building.position.z - animal.position.z, 2)
      );
      return distance <= 5; // Within building range
    });

    if (!isInBuilding) {
      return {
        canSleep: false,
        reason: "Must be inside a building to sleep safely. Consider building shelter or finding existing buildings."
      };
    }

    return {
      canSleep: true,
      reason: "Safe to sleep in building"
    };
  }

  private analyzePlanningContext(animal: Animal, worldState: any): PlanningContext {
    const urgentNeeds: string[] = [];
    
    // Analyze critical needs
    if (animal.stats.energy < 30) urgentNeeds.push("energy");
    if (animal.stats.hunger > 70) urgentNeeds.push("food");
    if (animal.stats.thirst > 70) urgentNeeds.push("water");
    if (animal.stats.health < 40) urgentNeeds.push("health");

    // Check for shelter need (if energy is low but can't sleep)
    const sleepCheck = this.canSleep(animal, worldState);
    if (animal.stats.energy < 50 && !sleepCheck.canSleep) {
      urgentNeeds.push("shelter");
    }

    // Count available resources in inventory
    const availableResources = {
      stone: animal.inventory.items.find(item => item.type === "stone")?.quantity || 0,
      wood: animal.inventory.items.find(item => item.type === "wood")?.quantity || 0,
      food: animal.inventory.items.find(item => item.type === "food")?.quantity || 0,
      water: animal.inventory.items.find(item => item.type === "water")?.quantity || 0,
    };

    return {
      urgentNeeds,
      availableResources,
      nearbyBuildings: worldState.nearbyBuildings || [],
      weatherThreat: false, // TODO: implement weather system
      socialOpportunities: (worldState.nearbyAnimals || []).map((a: any) => a.name),
      energyProjection: [], // No longer auto-generated, let LLM decide
      memoryInsights: [], // TODO: extract from exploration system memories
    };
  }

  private shouldReplan(animal: Animal, plan: AnimalPlan, context: PlanningContext): boolean {
    // Replan if confidence is too low
    if (plan.confidence < 0.3) return true;

    // Replan if urgent needs have changed dramatically
    const hasNewUrgentNeed = context.urgentNeeds.some(need => 
      !this.planAddressesNeed(plan, need)
    );
    if (hasNewUrgentNeed) return true;

    // Replan if plan is stale (more than 10 turns old)
    const turnsOld = (Date.now() - plan.createdAt) / 15000; // Assuming 15 seconds per turn
    if (turnsOld > 10) return true;

    // Replan if no valid steps remain
    if (plan.currentStepIndex >= plan.steps.length) return true;

    return false;
  }

  /**
   * Generate planning context for LLM to use
   */
  getPlanningContext(animal: Animal, worldState: any): PlanningContext {
    return this.analyzePlanningContext(animal, worldState);
  }

  private planAddressesNeed(plan: AnimalPlan, need: string): boolean {
    return plan.steps.some(step => {
      switch (need) {
        case "energy": return step.action === "sleeping";
        case "shelter": return step.action === "building";
        case "food": return step.action === "eating" || step.action === "harvesting";
        case "water": return step.action === "drinking" || step.action === "harvesting";
        default: return false;
      }
    });
  }

  private storePlanHistory(animalId: string, plan: AnimalPlan): void {
    if (!this.planningHistory.has(animalId)) {
      this.planningHistory.set(animalId, []);
    }
    const history = this.planningHistory.get(animalId)!;
    history.push({ ...plan }); // Store a copy
    
    // Keep only last 10 plans
    if (history.length > 10) {
      history.shift();
    }
  }

  /**
   * Get plan for debugging/display
   */
  getPlan(animalId: string): AnimalPlan | null {
    return this.plans.get(animalId) || null;
  }

  /**
   * Clear plan (for testing or when animal dies)
   */
  clearPlan(animalId: string): void {
    this.plans.delete(animalId);
  }
}

// Note: This is kept for type definitions only
// Planning is now handled client-side via ClientPlanningManager